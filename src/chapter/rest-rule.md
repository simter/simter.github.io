# REST 接口设计规范

## **概述**
本规范定义设计各种 REST 服务接口需要遵循的一般性准则，以保证各个项目、模块提供的 REST 服务接口符合统一的设计规范，方便项目、模块之间的接口对接。

## **适用范围**
本规范只针对 REST 数据接口，对于非数据接口，如动态模板等可能并不包含在此文档的说明范围内。

## **设计规范**

### **URL 命名规范**

REST URL 由资源路径、名称和请求参数组合而成，基本模式为：

```
/resource-path-1/.../resource-name[?param1=value1[&param2=value2...]]
```

**说明：**

1. resource-path、resource-name 为资源路径、名称，使用名词单数形式，字母全部用小写，单词间用中横线 "-" 连接
2. param 为参数名称，可以无也可以包含1个或多个，多个参数间用符号 "&" 连接，与 resource-path 间用符号 "?" 连接
3. value 的值必要时必须进行转义，避免与 URL 保留字冲突（如 ?、& 等）

**正确的例子：**

```
GET    /user-address        -- 用户地址列表
GET    /user?search=x       -- 带过滤条件 x 的用户列表
GET    /user/x              -- 获取 ID=x 的用户
DELETE /user/x              -- 删除 ID=x 的用户
POST   /user                -- 新建一个用户
PUT    /user/x              -- 更新 ID=x 的用户信息
GET    /user/admin/address  -- 用户 admin 地址列表
```

**错误的例子：**

```
GET    /users              -- 误用单词复数
GET    /userAddress        -- 误用驼峰命名
DELETE /userAddress/delete -- 不能用动词
```

### **REST CRUD 规范**

#### **创建新资源 (Create) - C/CRUD**

新建资源使用如下两种方式之一：

1. 使用 POST 创建未知资源ID（资源标识符）的新资源
2. 使用 PUT 创建指定资源ID（资源标识符）的新资源

使用 POST 创建新资源时要特别注意，由于 POST 是非幂等的，多次提交相同的 POST 请求会导致重复创建多份信息相同但资源ID不同的新资源，这可能并不是所期待的结果，除非服务端使用了额外的技术做了特别的防重复提交处理。

使用 PUT 创建新资源时，因为 PUT 是幂等的，多次提交也只会创建同一份资源。

请求体 (body) 不要求提交资源所有的属性值，提交的属性值用于设置资源的属性，没有提交的属性则由服务端视情况设置默认值。

不管使用哪种方式，资源创建成功后服务端需如下响应：

1. 请求体 (body) 承载要提交的资源属性信息，格式统一使用 json 对象的字符串压缩格式 (无空格、换行和注解)，如 {"code":"xm","name":"小明"}
2. 返回 "201 Created" 状态码
3. 通过 Location 响应头返回新建资源的位置，特别是使用方式 1 时
4. 如果需要返回更多额外的信息给请求方，则通过响应体 (body) 来承载，格式统一使用 json 对象的字符串压缩格式 (无空格、换行和注解)，如返回新建资源的ID和创建时间信息：{"id":123,"ts":"2016-01-01T10:30"}

POST 请求范例：

```
HTTP/1.1 POST /user

{"code":"xm","name":"小明"}
```

POST 响应范例：(成功)

```
201 Created
Location: http://api.com/user/1234567

{"id":"x","ts":"2016-01-01T10:30"}
```

PUT 请求范例：

```
HTTP/1.1 POST /user/x

{"code":"xm","name":"小明"}
```

PUT 响应范例：(成功)

```
201 Created

{"id":"x","ts":"2016-01-01T10:30"}
```

如果请求失败，服务端需如下响应：

1. 相应的 4xx 或 5xx 状态码
2. 通过响应体 body 返回失败的描述性信息，格式为纯文本，如：

```
403 Forbidden 

权限不足！
```

#### **更新资源 (Update) - U/CRUD**

更新资源有更新资源全部属性和更新资源部分属性两种情况，更新部分属性是应用中最常用的。执行资源更新前肯定已经预先知道资源的ID，重复执行相同的更新操作，在服务端对资源状态所产生的改变应该是相同的，符合幂等性原则，因此更新资源统一使用 PUT 方法。

资源更新成功后服务端需如下响应：

1. 请求体 (body) 承载要提交的资源属性信息，格式统一使用 json 对象的字符串压缩格式 (无空格、换行和注解)，如 {"code":"xm","name":"小明"}
2. 返回 "200 OK" 状态码
3. 如果需要返回更多额外的信息给请求方，则通过响应体 (body) 来承载，格式统一使用 json 对象的字符串压缩格式 (无空格、换行和注解)，如返回更新资源的实际时间：{"ts":"2016-01-01T10:30"}

请求范例：
```
HTTP/1.1 PUT /user/x

{"code":"xm","name":"小明"}
```

响应范例：(成功)
```
200 OK

{"ts":"2016-01-01T10:30"}
```

如果更新失败，服务端需如下响应：

1. 相应的 4xx 或 5xx 状态码
2. 通过响应体 body 返回失败的描述性信息，格式为纯文本，如：

```
404 Not Found

用户不存在！
```

#### **查询资源 (Read) - R/CRUD**

查询资源有查询单个资源的信息和查询一批资源的信息，不管哪种，都是统一使用 GET 方法。

资源查询成功后服务端需如下响应：

1. 返回 "200 OK" 状态码
2. 通过响应体 (body) 承载并返回资源的信息，格式统一使用 json 对象的字符串压缩格式 (无空格、换行和注解)

请求范例：(查询单个资源)
```
HTTP/1.1 GET /user/admin
```

响应范例：(成功)
```
200 OK

{"id":"admin","name":"管理员","sex":"男"}
```

请求范例：(查询多个资源 - 分页查询)
```
HTTP/1.1 GET /user?page-no=1
```

响应范例：(成功)
```
200 OK

{
  "rows": [
    {"id":"admin","name":"管理员"},
    {"id":"rj","name":"测试员"},
    ...
  ],
  "count": 1000
}
注：响应已作格式化显示，实际应为压缩格式
```

请求范例：(查询多个资源 - 非分页查询)
```
HTTP/1.1 GET /user
```

响应范例：(成功)
```
200 OK

[
  {"id":"admin","name":"管理员"},
  {"id":"rj","name":"测试员"},
  ...
]
注：响应已作格式化显示，实际应为压缩格式
```

如果查询失败，服务端需如下响应：

1. 相应的 4xx 或 5xx 状态码
2. 通过响应体 body 返回失败的描述性信息，格式为纯文本，如：

```
401 Unauthorized

请先登陆！
```

#### **删除资源 (Delete) - D/CRUD**

删除资源使用 DELETE 方法。删除成功后服务端响应返回状态码 "204 No Content" 即可。

请求范例：(删除单个资源)
```
HTTP/1.1 DELETE /user/admin
```

请求范例：(删除多个资源)
```
HTTP/1.1 DELETE /user/admin,rj
```

响应范例：(成功)
```
204 No Content
```

如果删除失败，服务端需如下响应：

1. 相应的 4xx 或 5xx 状态码
2. 通过响应体 body 返回失败的描述性信息，格式为纯文本，如：

```
403 Forbidden

请先登陆！
```

## **附注**

### **HTTP 方法的幂等性和安全性**

要设计统一的 REST 接口，必须真正理解 HTTP 方法的幂等性和安全性。

幂等性 (idempotence) 是指外系统对同一 REST 接口的多次访问，得到相同状态的资源。

安全性 (safty) 代表安全的 REST 接口，是指外系统对该接口的访问，不会改变服务端资源的状态。

  方法 | 幂等 | 安全
    ---|----|---
   GET | 是 | 是
DELETE | 是 | 否
  POST | 否 | 否
   PUT | 是 | 否
 PATCH | 否 | 否

注：
- PUT 被定义为幂等而 POST 则不是，这是一个很重要的区别
- PATCH 没有纳入 JAX-RS 2.0 标准

### **HTTP 常用状态码**

状态码 | 含义
---|----
**2xx**  | **成功**
200 OK | 服务器正常响应
201 Created | 创建新实体
202 Accepted | 服务器已接受请求，处理尚未完成。可用于异步处理机制
204 No Content | 服务器正常响应，但响应实体为空
**3xx**  | **重定向**
301 Moved Permanently | 请求资源的地址已永久移动到新位置，响应头 Location 指定新的位置
302 Found | 请求资源的地址发生临时变动，响应头 Location 指定新的临时位置
304 Not Modified | 客户端缓存资源依然有效
**4xx**  | **客户端错误**
400 Bad Request | 请求信息出现语法错误
401 Unauthorized | 请求资源无法授权给未验证用户
403 Forbidden | 请求资源未授权当前用户
404 Not Found | 请求资源不逊在
405 Method Not Allowed | 请求方法不匹配
406 Not Acceptable | 请求资源的媒体类型不匹配
**5xx**  | **服务器错误**
500 Internal Server Error | 服务器内部错误，意外终止响应
501 Not Implemented | 服务器不支持当前请求
502 Bad Gateway | 网关或代理执行请求时，从上游服务器接收到无效响应
503 Service Unavailable | 服务器当前无法处理请求


## **参考**

- PUT 还是 POST ? [中](https://www.oschina.net/translate/put-or-post)、[英](https://stormpath.com/blog/put-or-post)
- [Transparent PATCH Support in JAX-RS 2.0](https://dzone.com/articles/transparent-patch-support-jax)
